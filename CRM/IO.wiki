== IO ==

The $\rm IO$ class provides the following methods for performing simple input and output operations:
{{{
out_string(x : String) : SELF_TYPE
out_int(x : Int) : SELF_TYPE
in_string() : String
in_int() : Int
}}}
The methods $\rm out\_string$ and $\rm out\_int$ print their argument, flush the standard output, and return their $\rm self$ parameter.

The interpreter or compiler changes every $\rm \backslash t$ to a tab and every $\rm \backslash n$ to a newline in the argument $\rm x$ to $\rm out\_string$ before emitting the resulting string. Note that this is different from normal escape sequence handling, where $\rm \backslash n$ would be a single character stored in the string. In Cool, it is two characters, but $\rm out\_string$ prints a newline instead of $\rm \backslash n$.

The method $\rm in\_string$ reads a string from the standard input, up to but not including a newline character or the end of file. The newline character is consumed but is not made part of the returned string. If an error occurs then $\rm in\_string$ returns $\rm ""$, the string of length 0. Note that while literal lexical string constants are limited to size 1024, strings generated by $\rm in\_string$ (or $\rm String.concat$, etc.) can be of arbitrary size. There is no special processing of the two-character sequences $\rm \backslash t$ or $\rm \backslash n$ (or, indeed $\rm \backslash anything$) during $\rm in\_string$. Errors include:
* no input found before end of file
* string read in contains NUL, the character with ASCII value 0 (in which case the entire string is rejected, even if there are valid characters around the NUL)

The method $\rm in\_int$ reads a single possibly-signed integer, which may be preceded by whitespace. Any characters following the integer, up to and including the next newline, are discarded by $\rm in\_int$. If an error occurs then $\rm in\_int$ returns 0. Errors include:
* no input found before end of file
* malformed input (i.e., first thing after whitespace is not a possibly-signed integer)
* integer read in is $\rm <$ -2147483648
* integer read in is $\rm >$ +2147483647

A class can make use of the methods in the $\rm IO$ class by inheriting from $\rm IO$. It is an error to redefine the $\rm IO$ class.
